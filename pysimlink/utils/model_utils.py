import glob
import os
from typing import Union

from pysimlink.utils.file_utils import get_other_in_dir

from pysimlink.lib.compilers.one_shot_compiler import NoRefCompiler
from pysimlink.lib.compilers.model_ref_compiler import ModelRefCompiler


class ModelPaths:
    simulink_native: str ## path to the directory containing stuff generated by simulink for every model
    root_model_path: str ## Path to the root model
    root_model_name: str ## Name of the root model
    has_references: bool ## If this model contains references
    models_dir: str      ## directory containing all simulink code related to the models
    slprj_dir: Union[str,None]
    def __init__(self,
                 root_dir: str,
                 model_name: str,
                 compile_type: str='grt',
                 suffix: str='rtw',
                 tmp_dir: Union[str,None]=None):
        walk = os.walk(root_dir, followlinks=False)
        for (cur_path, folders, files) in walk:
            if 'simulink' in folders: 
                self.simulink_native = cur_path
                break
        else:
            raise RuntimeError(f'{root_dir} is not a valid simulink model.')
        
        models_dir = get_other_in_dir(root_dir, os.path.basename(self.simulink_native))
        self.models_dir = os.path.join(root_dir, models_dir)

        self.has_references = os.path.exists(os.path.join(self.models_dir, 'slprj'))

        self.root_model_path = os.path.join(self.models_dir, model_name+"_"+compile_type+"_"+suffix)
        if not os.path.exists(self.root_model_path):
            try:
                model_name = model_name.split('_'+compile_type+"_"+suffix)[0]
            except:
                pass
            self.root_model_path = os.path.join(self.models_dir, model_name+"_"+compile_type+"_"+suffix)
            if not os.path.exists(self.root_model_path):
                raise RuntimeError(f"Cannot find folder with name '{model_name}' in '{self.models_dir}'")
        self.model_name = model_name
        if self.has_references:
            self.slprj_dir = os.path.join(self.models_dir, 'slprj', compile_type)

        if tmp_dir is None:
            import sys
            self.tmp_dir = os.path.join(os.path.dirname(sys.argv[0]), "__pycache__", "pysimlink", self.model_name)
        else:
            self.tmp_dir = os.path.join(tmp_dir, model_name)
        os.makedirs(self.tmp_dir, exist_ok=True)
        self.verify_capi()
        
    def verify_capi(self):
        """
        Make sure that this model was generated with the c api. This doesn't use
        the function in the capi, but we need the model mapping interface (mmi).
        """
        files = glob.glob(self.root_model_path + "/*.c", recursive=False)
        files = map(os.path.basename, files)
        assert self.model_name + "_capi.c" in files, \
            "Model not generated with capi"

    def compiler_factory(self):
        """
        Return the correct compiler. This could be simplified later -or- more
        compilers could be added if we want to use something other than cmake. 
        """
        if self.has_references:
            return ModelRefCompiler(self)
        else:
            return NoRefCompiler(self)
