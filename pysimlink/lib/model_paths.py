import os
import glob
from typing import Union
from pysimlink.utils.file_utils import get_other_in_dir

class ModelPaths:
    root_dir: str  ## Directory containing all model components.
    simulink_native: str  ## path to the directory containing stuff generated by simulink for every model
    root_model_path: str  ## Path to the root model
    root_model_name: str  ## Name of the root model
    compile_type: str  ## grt, ert, etc...
    suffix: str  ## Suffix added to the model name. Usually 'rtw'
    has_references: bool  ## If this model contains references
    models_dir: str  ## directory containing all simulink code related to the models
    slprj_dir: Union[str, None]  ## Directory will all child models (contains compile_type)

    def __init__(self,
                 root_dir: str,
                 model_name: str,
                 compile_type: str = 'grt',
                 suffix: str = 'rtw',
                 tmp_dir: Union[str, None] = None):
        """

        :param root_dir: Directory created during codegen. Should have two directories in it.
        :param model_name: Name of the root model.
        :param compile_type: grt, ert, etc...
        :param suffix: the suffix added to the model name directory. usually 'rtw'
        :param tmp_dir: Where to store the build files. Defaults to __pycache__
        """
        self.compile_type = compile_type
        if self.compile_type != 'grt':
            raise ValueError("Unsupported compile target. grt is the only supported simulink code generation target.\n"
                             f"Change your code generation settings to use the grt.tlc target and try again. (compile_type should be `grt` not {self.compile_type})")
        self.suffix = suffix
        self.root_dir = root_dir

        walk = os.walk(root_dir, followlinks=False)
        for (cur_path, folders, files) in walk:
            if 'simulink' in folders:
                self.simulink_native = cur_path
                break
        else:
            raise RuntimeError(f'{root_dir} is not a valid simulink model.')

        models_dir = get_other_in_dir(root_dir, os.path.basename(self.simulink_native))
        self.models_dir = os.path.join(root_dir, models_dir)

        self.has_references = os.path.exists(os.path.join(self.models_dir, 'slprj'))

        self.root_model_path = os.path.join(self.models_dir, model_name + "_" + compile_type + "_" + suffix)
        if not os.path.exists(self.root_model_path):
            try:
                model_name = model_name.split('_' + compile_type + "_" + suffix)[0]
            except:
                pass
            self.root_model_path = os.path.join(self.models_dir, model_name + "_" + compile_type + "_" + suffix)
            if not os.path.exists(self.root_model_path):
                raise RuntimeError(f"Cannot find folder with name '{model_name}' in '{self.models_dir}'")
        self.root_model_name = model_name
        if self.has_references:
            self.slprj_dir = os.path.join(self.models_dir, 'slprj', compile_type)

        if tmp_dir is None:
            import sys
            self.tmp_dir = os.path.join(os.path.dirname(sys.argv[0]), "__pycache__", "pysimlink", self.root_model_name)
        else:
            self.tmp_dir = os.path.join(tmp_dir, model_name)
        os.makedirs(self.tmp_dir, exist_ok=True)
        self.verify_capi()

    def verify_capi(self):
        """
        Make sure that this model was generated with the c api. This doesn't use
        the function in the capi, but we need the model mapping interface (mmi).
        """
        files = glob.glob(self.root_model_path + "/*.c", recursive=False)
        files = map(os.path.basename, files)
        assert self.root_model_name + "_capi.c" in files, \
            "Model not generated with capi"

    def compiler_factory(self):
        """
        Return the correct compiler. This could be simplified later -or- more
        compilers could be added if we want to use something other than cmake.
        """
        if self.has_references:
            from pysimlink.lib.compilers.model_ref_compiler import ModelRefCompiler
            return ModelRefCompiler(self)
        else:
            from pysimlink.lib.compilers.one_shot_compiler import NoRefCompiler
            return NoRefCompiler(self)